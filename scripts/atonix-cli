#!/usr/bin/env python3
"""
AtonixCorp CLI - Platform Management Tool
Manages services, deployments, and platform operations
"""

import sys
import os
import json
import argparse
import subprocess
import yaml
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)


class AtonixCLI:
    """Main CLI interface for AtonixCorp Platform."""
    
    def __init__(self):
        self.config_file = Path.cwd() / "atonix.yaml"
        self.env_file = Path.cwd() / ".env"
        self.service_config = self._load_config()
    
    def _load_config(self) -> Optional[Dict[str, Any]]:
        """Load atonix.yaml configuration."""
        if not self.config_file.exists():
            return None
        
        try:
            with open(self.config_file, 'r') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"Failed to load atonix.yaml: {e}")
            return None
    
    def init(self, args):
        """Initialize a new AtonixCorp service."""
        service_name = args.name or input("Enter service name: ").strip()
        runtime = args.runtime or "container"
        
        # Create atonix.yaml template
        config = {
            "apiVersion": "atonix.io/v1",
            "kind": "Service",
            "metadata": {
                "name": service_name,
                "createdAt": datetime.now().isoformat(),
                "version": "1.0.0"
            },
            "service": {
                "name": service_name,
                "runtime": runtime,
                "replicas": 2,
                "description": f"{service_name} service"
            },
            "autoscaling": {
                "enabled": True,
                "min": 2,
                "max": 20,
                "targetCPU": 70,
                "targetMemory": 80
            },
            "resources": {
                "cpu": "500m",
                "memory": "512Mi"
            },
            "health": {
                "liveness": "/health",
                "readiness": "/ready",
                "periodSeconds": 30,
                "timeoutSeconds": 5,
                "failureThreshold": 3
            },
            "env": [],
            "ports": [
                {
                    "name": "http",
                    "containerPort": 8080,
                    "protocol": "TCP"
                }
            ],
            "security": {
                "runAsNonRoot": True,
                "readOnlyRootFilesystem": True,
                "allowPrivilegeEscalation": False,
                "capabilities": {
                    "drop": ["ALL"]
                }
            },
            "observability": {
                "logging": {
                    "format": "json",
                    "level": "info"
                },
                "metrics": {
                    "enabled": True,
                    "port": 9090,
                    "path": "/metrics"
                },
                "tracing": {
                    "enabled": True,
                    "sampling_rate": 0.1
                }
            }
        }
        
        # Create directory structure
        directories = ["src", "config", "deploy", "tests"]
        for dir_name in directories:
            Path(dir_name).mkdir(exist_ok=True)
            (Path(dir_name) / ".gitkeep").touch()
        
        # Write atonix.yaml
        with open("atonix.yaml", "w") as f:
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)
        
        # Create Dockerfile template
        dockerfile_content = f"""FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY src/ /app/

EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
    CMD curl -f http://localhost:8080/health || exit 1

CMD ["python", "-m", "app.main"]
"""
        with open("Dockerfile", "w") as f:
            f.write(dockerfile_content)
        
        # Create README template
        readme_content = f"""# {service_name}

{service_name} service for AtonixCorp Platform.

## Quick Start

```bash
# Build
docker build -t {service_name} .

# Run
docker run -p 8080:8080 {service_name}

# Deploy
atonix deploy
```

## Configuration

See `atonix.yaml` for configuration options.

## Health Checks

- Liveness: GET /health
- Readiness: GET /ready
"""
        with open("README.md", "w") as f:
            f.write(readme_content)
        
        logger.info(f"✓ Initialized AtonixCorp service: {service_name}")
        logger.info("✓ Created atonix.yaml, Dockerfile, README.md")
        logger.info(f"✓ Created directories: {', '.join(directories)}")
    
    def build(self, args):
        """Build the service docker image."""
        if not self.config_file.exists():
            logger.error("atonix.yaml not found. Run 'atonix init' first.")
            return
        
        service_name = self.service_config["service"]["name"]
        tag = args.tag or f"{service_name}:latest"
        
        logger.info(f"Building {tag}...")
        result = subprocess.run(
            ["docker", "build", "-t", tag, "."],
            cwd=Path.cwd()
        )
        
        if result.returncode == 0:
            logger.info(f"✓ Built {tag}")
        else:
            logger.error("Build failed")
            sys.exit(1)
    
    def test(self, args):
        """Run service tests."""
        logger.info("Running tests...")
        
        # Run unit tests
        test_dirs = ["tests", "test"]
        test_found = False
        
        for test_dir in test_dirs:
            if Path(test_dir).exists():
                test_found = True
                result = subprocess.run(
                    ["python", "-m", "pytest", test_dir, "-v"],
                    cwd=Path.cwd()
                )
                if result.returncode != 0:
                    sys.exit(1)
        
        if not test_found:
            logger.warning("No tests found")
    
    def deploy(self, args):
        """Deploy service to cluster."""
        if not self.config_file.exists():
            logger.error("atonix.yaml not found")
            return
        
        service_name = self.service_config["service"]["name"]
        environment = args.environment or "staging"
        
        logger.info(f"Deploying {service_name} to {environment}...")
        logger.info(f"Replica count: {self.service_config['service']['replicas']}")
        logger.info(f"Resources: {self.service_config['resources']}")
        
        # Generate Kubernetes manifests
        k8s_manifest = self._generate_k8s_manifest(environment)
        
        # Create deploy directory
        deploy_dir = Path("deploy")
        deploy_dir.mkdir(exist_ok=True)
        
        manifest_file = deploy_dir / f"{service_name}-{environment}.yaml"
        with open(manifest_file, "w") as f:
            yaml.dump_all(k8s_manifest, f, default_flow_style=False)
        
        # Apply to cluster
        if args.apply:
            result = subprocess.run(
                ["kubectl", "apply", "-f", str(manifest_file)],
                cwd=Path.cwd()
            )
            if result.returncode == 0:
                logger.info(f"✓ Deployed to {environment}")
            else:
                logger.error("Deployment failed")
                sys.exit(1)
        else:
            logger.info(f"Manifest generated: {manifest_file}")
    
    def _generate_k8s_manifest(self, environment: str) -> list:
        """Generate Kubernetes manifest from atonix.yaml."""
        config = self.service_config
        service_name = config["service"]["name"]
        replicas = config["service"]["replicas"]
        
        namespace = f"{service_name}-{environment}"
        
        manifests = []
        
        # Namespace
        manifests.append({
            "apiVersion": "v1",
            "kind": "Namespace",
            "metadata": {"name": namespace}
        })
        
        # Deployment
        manifests.append({
            "apiVersion": "apps/v1",
            "kind": "Deployment",
            "metadata": {
                "name": service_name,
                "namespace": namespace,
                "labels": {"app": service_name}
            },
            "spec": {
                "replicas": replicas,
                "selector": {"matchLabels": {"app": service_name}},
                "template": {
                    "metadata": {"labels": {"app": service_name}},
                    "spec": {
                        "containers": [{
                            "name": service_name,
                            "image": f"{service_name}:latest",
                            "ports": [{"containerPort": 8080}],
                            "livenessProbe": {
                                "httpGet": {
                                    "path": config["health"]["liveness"],
                                    "port": 8080
                                },
                                "periodSeconds": config["health"]["periodSeconds"]
                            },
                            "readinessProbe": {
                                "httpGet": {
                                    "path": config["health"]["readiness"],
                                    "port": 8080
                                },
                                "periodSeconds": config["health"]["periodSeconds"]
                            },
                            "resources": {
                                "requests": {
                                    "cpu": config["resources"]["cpu"],
                                    "memory": config["resources"]["memory"]
                                }
                            }
                        }]
                    }
                }
            }
        })
        
        # Service
        manifests.append({
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": {
                "name": service_name,
                "namespace": namespace,
                "labels": {"app": service_name}
            },
            "spec": {
                "type": "ClusterIP",
                "selector": {"app": service_name},
                "ports": [{
                    "port": 8080,
                    "targetPort": 8080,
                    "protocol": "TCP"
                }]
            }
        })
        
        return manifests
    
    def monitor(self, args):
        """Monitor service health and metrics."""
        service_name = args.service
        
        logger.info(f"Monitoring {service_name}...")
        logger.info(f"kubectl logs -f deployment/{service_name}")
        
        result = subprocess.run(
            ["kubectl", "logs", "-f", f"deployment/{service_name}"]
        )
    
    def login(self, args):
        """Authenticate with AtonixCorp."""
        logger.info("Authenticating with AtonixCorp...")
        
        # This would integrate with actual auth system
        # For now, just create a token file
        credentials = {
            "token": "atonix_token_placeholder",
            "authenticated_at": datetime.now().isoformat()
        }
        
        creds_file = Path.home() / ".atonix" / "credentials.json"
        creds_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(creds_file, "w") as f:
            json.dump(credentials, f)
        
        logger.info("✓ Authenticated successfully")
    
    def status(self, args):
        """Check platform and service status."""
        logger.info("Checking AtonixCorp Platform status...")
        
        # Check Kubernetes
        result = subprocess.run(
            ["kubectl", "cluster-info"],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            logger.info("✓ Kubernetes cluster connected")
        else:
            logger.error("✗ Kubernetes cluster not accessible")
        
        # Check services
        result = subprocess.run(
            ["kubectl", "get", "services", "--all-namespaces"],
            capture_output=True,
            text=True
        )
        
        logger.info("\nServices running:")
        print(result.stdout)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="AtonixCorp Platform CLI"
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # init command
    init_parser = subparsers.add_parser("init", help="Initialize new service")
    init_parser.add_argument("--name", help="Service name")
    init_parser.add_argument("--runtime", default="container", help="Runtime (container/serverless)")
    
    # build command
    build_parser = subparsers.add_parser("build", help="Build service")
    build_parser.add_argument("--tag", help="Docker image tag")
    
    # test command
    test_parser = subparsers.add_parser("test", help="Run tests")
    
    # deploy command
    deploy_parser = subparsers.add_parser("deploy", help="Deploy service")
    deploy_parser.add_argument("--environment", default="staging", help="Target environment")
    deploy_parser.add_argument("--apply", action="store_true", help="Apply the deployment")
    
    # monitor command
    monitor_parser = subparsers.add_parser("monitor", help="Monitor service")
    monitor_parser.add_argument("service", help="Service name")
    
    # login command
    login_parser = subparsers.add_parser("login", help="Authenticate")
    
    # status command
    status_parser = subparsers.add_parser("status", help="Check platform status")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    cli = AtonixCLI()
    
    if args.command == "init":
        cli.init(args)
    elif args.command == "build":
        cli.build(args)
    elif args.command == "test":
        cli.test(args)
    elif args.command == "deploy":
        cli.deploy(args)
    elif args.command == "monitor":
        cli.monitor(args)
    elif args.command == "login":
        cli.login(args)
    elif args.command == "status":
        cli.status(args)


if __name__ == "__main__":
    main()
